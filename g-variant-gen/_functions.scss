///move to general utilitisz
@function is-single-item($value) {

    @return (type-of($value) != map and ( length($value) >= 1 ));
}

///remap merges values with option maps

@function remap-value($value:false, $_options:false, $value-key: v /* if value is a single item , map with this key*/
) {
    @if (is-map($value ) == false) {
        $test: _first($value);
        @if (_is-function(_first($value))) {
            $value: call(get-function(_first($value)), _drop($value, 1)...);
        }
        @return _assign((#{$value-key}: $value), $_options);
    } @else {
        @return map-merge($_options, $value);
    }
}
@function no-transformation($v){
    @return $v;
}
@function assign($unit:(),$props:(),$additional-parameters:false) {

    @if is-single-item($props) and is-single-item($unit) {
        @return map-set((), _to-string($props), $unit); ///if there are additional options, item needs to be put in map instead of returned
    }@else if (_is-map($unit) and is-single-item($props)){
        @return map-set((), _to-string($props), map-values($unit)); ///if there are additional options, item needs to be put in map instead of returned

    } @else {

    }
    @return false;
}

@function include($units:(),$props:(),$additional-parameters:false) {

    @return _pick($units, $props);
}

@function exclude($units:(),$props:(),$additional-parameters:false) {

    @return _omit($units, $props);

}

@function transform-data($units : () , $options:false,$transform:false,$var:v /* transformed ones variable name if it neds one*/
) {
    $map-to-return: ();
    $_transform-result: false;

    @if (type-of($units) == map) {
        @each $key, $value in $units {
            $new-key: false;
            $new-value: false;
            ///if its a key (sm ) and not a value...
            @if (map-get($units, $key)) {
                $new-key: $key;
                $new-value: map-get($units, $key);
            } @else {

                $new-key: index($units, $key); //have to flip flop these.
                $new-value: nth($units, $new-key);
            }
           // @debug "TRYING TO TRANSFORM key: #{$new-key} value: #{$new-value}";
            $new-value: remap-value($new-value, $options, $var);

            @if (_is-function($transform)) {
                $_transform-result: call(get-function($transform), $new-value...);
              // $_transform-result:  _map($new-value, $transform);
                //this seems wrong?? $_transform-result:  _map($new-value, $transform);
            } @else {
                $_transform-result: map-merge($options, $new-value);
            }
            $map-to-return: map-set($map-to-return, $new-key, $_transform-result);
        }
    } @else {
        @error "BAD DATA OBJECT";
    }
    @return $map-to-return;
}

//take calculated and filter map
@function get-rendered-data($units:(), $props:() , $filter: false, $prefix:false,$module:false) {

    $filtered-unit-arr: $units;
    @if ($filter==false) {
        @return $units;
    }
    @if (_is-function($filter)) {

        //TODO USE SASSDASH
        @each $key, $value in $units {

            //add key with empty array
            $filtered-unit-arr: map-set($filtered-unit-arr, $key, ());

            //filter map with props
            $transformed-val: call(get-function($filter), $value, $props);

            //replace with new
            $filtered-unit-arr: map-set($filtered-unit-arr, $key, $transformed-val);
        }
    } @else {
        @debug "NOT A FUNCTION";
    }
    @return $filtered-unit-arr;
}


@function get-render-type($collection){
    @if (_($collection,is-render-key) ) {
        @error "ITS A RENDER KEY!!";
        @return key;
    }
    @if (_($collection, is-render-map)){
        // @warn "THIS IS A RENDER MAP!!!";
        @return map;
    }
    @if( _($collection, is-render-collection)){
        // @warn "IS COLLECTION";
        @return collection;
    }

    @error "BROKEN ENTRY";
    @return false;
}
