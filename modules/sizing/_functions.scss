///stub functions
@function get-module-sizing() {
    @return true;
}

@function get-dependancies-sizing() {
    @return (
            (rhythm): true,
            (ms):true, ///modular scale,
    );
}

//*** custom TRANSFORMATION FUNCTIONTIONS for scale maps
//ms: MODULAR SCALE function

//rs: RATIO SIZE
@function rs($v,$base: 0) {

    @debug "CALLING RS #{$v} #{$base}";
    @if ($v==0) {
        @return 0;
    }
    @if (type-of ($v)== number and has-unit($v)==false) {
        //@return "cant mutiplu";
        @return ($v * $base);
    } @else {
        @return 0;
    }
}

//rs: FIXED SIZE

@function fs($v,/* it seeems like these dummy need to be present to not fuck it up*/$base: false,$ratio: false) {
    @return $v;
}

////********MODULE HELPERS

@function get-scale-def($_key, $_scale-definition-collection: $scale-map) {
    @return map-get($_scale-definition-collection, $_key);
}

//*****VALIDATORS
@function validate-scale-definition-key ($_key, $_scale-definition-collection: $scale-map) {
    @return map-get($_scale-definition-collection, $_key);
}

@function is-valid-lookup-key($_scale-def-key,$_key) {

    $_scale-def: $_scale-def-key;

    @if (type-of($_scale-def-key) == string) {
        $_scale-def: get-scale-def($_scale-def-key);
    }
    $unit-lookup: map-get($_scale-def, units);
    @return ($unit-lookup and map-has-key($unit-lookup, $_key));
}

@function is-valid-transformation($_transformation-str) {
    @return ($_transformation-str and function_exists($_transformation-str));
}

@function get-value-by-key($_scale-def-key,$_key) {
    ///might not work like this
    @if ($_scale-def-key ==false or $_key == false) {
        @return false;
    }
    $unit-lookup: map-get($_scale-def-key, units);
    //if it has the unit propeety, then if it has the specific key .
    @if ($unit-lookup and map-has-key($unit-lookup, $_key)) {
        @return map-get($unit-lookup, $_key);
    } @else {
        @error "PROBLEM WITH KEY ";
    }
}

@function only-auto($value) {
    @return ($value == md);

}

@function is-single-item($value) {
    @return (type-of($value) != map and length($value) == 1);
}

//@function sizing-key-to-value($function, $key-list:false,$options:false,$list-value-var: v)

@function transform-each($_sourceArr :false /***unit map ***/, $_transform-func:false, $_options:false, $list-value-var: v) {

    $_transform-result: false;
    $map-to-return: ();
    //don't do anything.
    @if (is-function($_transform-func) ==false) {
        @return false;
    }
    //loops thru target keys to make a new list of values;
    @if (is-iterable($_sourceArr)) {

        @each $key, $value in $_sourceArr {

            $_new-map: false;

            @if (type-of($_options) == map and is-function($_transform-func)) {
                // merge map  if function needs additional options  parameters with value to call function .

                @if (is-single-item($value)) {

                    $_new-map: map-set((), $list-value-var, $value); ///if there are additional options, item needs to be put in map instead of returned
                }
                $_new-map: map-merge($_new-map, $_options);

                ////call transformation function
                $_transform-result: call(get-function($_transform-func), $_new-map...);

            } @else if (is-function($_transform-func)) {
                //use plain value
                $_transform-result: call(get-function($_transform-func), $value);

                @debug "ERROR #{$_transform-result}";
            }

            @if ($_transform-result != false) {
                $map-to-return: map-set($map-to-return, $key, $_transform-result);
            }
        }
        @return $map-to-return;
    }
}

@function sizing-key-to-value($target-keys:false,$value-lookup-map:false /***unit map ***/, $filter-func:false,$list-value-var: v) {

    $output: "";

    //loops thru target keys to make a new list of values;
    @if (is-iterable($target-keys)) {

        @each $target-key, $index in $target-keys {

            $i: index($target-keys, $target-key);
            $value-to-write: "";

            @if (is-map($value-lookup-map) and   map-get($value-lookup-map,$target-key)) {
                $value-to-write: append($output, map-get($value-lookup-map, $target-key));
            } @else { // sizing-key-to-value(sm 30px sm, (sm:140px )  //this only works with length values right now.
                $value-to-write: $target-key;
            }

            //function to filter values?
            @if (is-function($filter-func)) {
                @if (call(get-function($filter-func),$value-to-write) ==true) {
                    $value-to-write: $value-to-write;
                } @else if (/*//is boolean*/
                    is-boolean(call(get-function($filter-func), $value-to-write))) {
                    $value-to-write: call(get-function($filter-func), $value-to-write);
                }
            }
            $output: append($output, $value-to-write);
        }
        @return $output;
    }
}

// /replacement ms function becomes a 'gate' .
@function get-scale-value($_scale-def-key:type /* can be a scale def KEY or scaledef map */, $_value:1 /*value OR value key*/
) {
    ///if the definition key can either be a key in the scale definition objects "units" prop,
    // or it can be the whole scale definition (if one isnt registered or something "on the fly' modifications.

    $current-scale-definition: ();
    $current-value: false;

    @if (type-of($_scale-def-key)==map) {
        $current-scale-definition: $_scale-def-key;
    } @else if (validate-scale-definition-key($_scale-def-key)) {

        //  @debug "---------------------------------------";

        $current-scale-definition: get-scale-def($_scale-def-key);
    }

    //see if the value is a key that needs to be converted to the actual value/
    @if (is-valid-lookup-key($current-scale-definition, $_value)) {
        $current-value: get-value-by-key($current-scale-definition, $_value);

        //  @debug "scale definition , : #{$current-scale-definition} cleanvalue #{$_value} value processed: #{$current-value}";

    } @else if ($_value) {
        $current-value: $_value;
        /// defined values can be assigned directly.
    }
    $transformation-func: false;
    //check to see if transformation needs to be applied. if none present, just return the value.
    @if (is-valid-transformation(map-get($current-scale-definition, transform))) {

        $transformation-func: get-function(map-get($current-scale-definition, transform));
        //apply the transformation i guess???

    }

    ///options ( SHOULD BE A MAP. )
    $_options: (map-get($current-scale-definition, options));
    //todo: mybe validate function here
    @if ($_options == undefined or type-of($_options) != map) {
        $_options: ();
    }

    $args: (v:$current-value); //map default args object

    //merge the maps with additional parameters for functions.
    $args: map-merge($args, $_options);

    @if ($transformation-func) {
        ///do transformation

        @return call($transformation-func, $args...);

    } @else {
        ///return the args object
        @return $args;
    }

    //in order to provide a VALUE to a transformation function, it needs to be a NUMBER.    2, or 20px are acceptable values.
    @return false;
}