///stub functions
@function get-module-sizing() {
    @return true;
}

@function get-dependancies-sizing() {
    @return (
            (rhythm): true,
            (ms):true, ///modular scale,
    );
}

//*** custom TRANSFORMATION FUNCTIONTIONS for scale maps
//ms: MODULAR SCALE function

//rs: RATIO SIZE
@function rs($v,$base: 0) {

    @debug "CALLING RS #{$v} #{$base}";
    @if ($v==0) {
        @return 0;
    }
    @if (type-of ($v)== number and has-unit($v)==false) {
        //@return "cant mutiplu";
        @return ($v * $base);
    } @else {
        @return 0;
    }
}

//rs: FIXED SIZE

@function fs($v,/* it seeems like these dummy need to be present to not fuck it up*/$base: false,$ratio: false) {
    @return $v;
}

////********MODULE HELPERS

@function get-scale-def($_key, $_scale-definition-collection: $scale-map) {
    @return map-get($_scale-definition-collection, $_key);
}

//*****VALIDATORS
@function validate-scale-definition-key ($_key, $_scale-definition-collection: $scale-map) {
    @return map-get($_scale-definition-collection, $_key);
}

@function is-valid-lookup-key($_scale-def-key,$_key) {

    $_scale-def: $_scale-def-key;

    @if (type-of($_scale-def-key) == string) {
        $_scale-def: get-scale-def($_scale-def-key);
    }
    $unit-lookup: map-get($_scale-def, units);
    @return ($unit-lookup and map-has-key($unit-lookup, $_key));
}

@function is-valid-transformation($_transformation-str) {
    @return ($_transformation-str and function_exists($_transformation-str));
}

@function get-value-by-key($_scale-def-key,$_key) {
    ///might not work like this
    @if ($_scale-def-key ==false or $_key == false) {
        @return false;
    }
    $unit-lookup: map-get($_scale-def-key, units);
    //if it has the unit propeety, then if it has the specific key .
    @if ($unit-lookup and map-has-key($unit-lookup, $_key)) {
        @return map-get($unit-lookup, $_key);
    } @else {
        @error "PROBLEM WITH KEY ";
    }
}

@function only-auto($value) {
    @return ($value == md);

}

@function is-single-item($value) {
    @return (type-of($value) != map and ( length($value) >= 1 ) );
}

///remap merges values with option maps
@function remap-value($value:false, $_options:false, $value-key: v /* if value is a single item , map with this key*/){

    @if (type-of($_options) == map) {
        // merge map  if function needs additional options  parameters with va
        $_new-map:false;

        @if (is-single-item($value)) {

            $_new-map: map-set((), $value-key, $value); ///if there are additional options, item needs to be put in map instead of returned
        }@else if (is-map($value)){

            $_new-map: $value;
        }

        @if ( is-map($_new-map) ){
            $_new-map: map-merge($_new-map, $_options);

        }@else{
            @error "EEERRRORO tryng to merge non - map value ";
        }
        @return $_new-map;
    }@else {
        @return $value;
    }

}
//this will transform EACH UNIT of the map.
@function transform-each($_sourceArr :false /***unit map ***/, $_transform-func:false, $_options:false, $map-key-var: v) {


    //loops thru target keys to make a new list of values;
    @if (is-iterable($_sourceArr)) {

        $_transform-result: false;
        $map-to-return: ();

        $is-single-item: false;

        @if (is-single-item($_sourceArr)) {
            //if it is a single item.
            @if (length($_sourceArr) == 1) {
                $is-single-item: true;
            }
        }

        @each $key, $value in $_sourceArr {

            $new-key: false;
            $new-value: false;

            ///if its a key (sm ) and not a value...
            @if (is-map($_sourceArr) and map-get($_sourceArr,$key)) {
                $new-key: $key;


                $new-value: map-get($_sourceArr, $key);
            } @else {

                $new-key: index($_sourceArr, $key); //have to flip flop these.
                $new-value: nth($_sourceArr, $new-key);
            }

            $new-value: remap-value($new-value, $_options, $map-key-var);

            @if (is-function($_transform-func)) {


                $_transform-result: call(get-function($_transform-func), $new-value...);
            } @else {
                $_transform-result: $new-value;
            }

            @if ($is-single-item) {
                @return $_transform-result;
            }
            $map-to-return: map-set($map-to-return, $new-key, $_transform-result);
        }

        @return $map-to-return;
    }
}

/*$args:(
    _sourceArr:false,
    _transform-func:false,
    _options:false,
    _map-key-var:v

)*///$_args: (_sourceArr:false,_transform-func:false, _options:false, _map-key-var:v)
//new function to transform a single value "sm" or list of values: margin: sm sm 20px lg
@function transform-by-list($target-list:false /*CAN BE LIST w single item */ ,$sourceArr :false /***unit map ***/, $transform-func:false, $options:false, $map-key-var: v ) {

    $_output-list:"";

    $_result-map : transform-each($sourceArr,$transform-func,$options,$map-key-var);

    @if (is-iterable($target-list)) {

        @each $_target-key, $index in $target-list {

            $i: index($target-list, $_target-key);
            $value-to-write: "";

            @if (is-map($_result-map) and   map-get($_result-map,$_target-key)) {
             //if its a map, and the key is found...
            //todo: this might be wrong??
                $value-to-write: append($value-to-write, map-get($_result-map, $_target-key));
            } @else { // sizing-key-to-value(sm 30px sm, (sm:140px )  //this only works with length values right now.
               //// if it is a single value...
                $value-to-write: $_target-key;
            }

            $_output-list: append($_output-list, $value-to-write);
        }

    }
    @return $_output-list;
}

@function sizing-key-to-value($target-keys:false,$value-lookup-map:false /***unit map ***/, $filter-func:false,$_options:false,$list-value-var: v) {

    $output: "";

    ////ARGS?SPREAD? ???
$resultMap : transform-each($value-lookup-map, $filter-func, $_options,$list-value-var);


    //loops thru target keys to make a new list of values;
    @if (is-iterable($target-keys)) {

        @each $target-key, $index in $target-keys {

            $i: index($target-keys, $target-key);
            $value-to-write: "";




            @if (is-map($value-lookup-map) and   map-get($value-lookup-map,$target-key)) {
                $value-to-write: append($output, map-get($value-lookup-map, $target-key));
            } @else { // sizing-key-to-value(sm 30px sm, (sm:140px )  //this only works with length values right now.
                $value-to-write: $target-key;
            }

            //function to filter values?
            @if (is-function($filter-func)) {
                @if (call(get-function($filter-func),$value-to-write) ==true) {
                    $value-to-write: $value-to-write;
                } @else if (/*//is boolean*/
                    is-boolean(call(get-function($filter-func), $value-to-write))) {
                    $value-to-write: call(get-function($filter-func), $value-to-write);
                }
            }
            $output: append($output, $value-to-write);
        }
        @return $output;
    }
}
///rewrite of this

// /replacement ms function becomes a 'gate' .
@function get-scale-value($_scale-def-key:type /* can be a scale def KEY or scaledef map */, $_value:1 /* can also be list sm lg value OR value key*/
) {
    ///if the definition key can either be a key in the scale definition objects "units" prop,
    // or it can be the whole scale definition (if one isnt registered or something "on the fly' modifications.

    $current-scale-definition: ();


    $defaults:(
        _target-list:false,
        _sourceArr:false,
        _transform-func:false,
        _options:false
    );

    @if (is-map($_scale-def-key)) {
        $current-scale-definition: $_scale-def-key;
    } @else if (validate-scale-definition-key($_scale-def-key)) {
        $current-scale-definition: get-scale-def($_scale-def-key);
    }

///todo:rework this.
    $_units: if( map-get($current-scale-definition, units), map-get($current-scale-definition, units),false  );
    $transformation-func: if(map-get($current-scale-definition, transform), map-get($current-scale-definition, transform),false);
    $_options: if(map-get($current-scale-definition, options), map-get($current-scale-definition, options),false);


    $defaults:(
        target-list:$_value,
        sourceArr:$_units,
        transform-func:$transformation-func,
        options:$_options
    );

    $result: transform-by-list($defaults...);  ////possibly add a validation parameter if it comes bACK false.
 //   @error "#{$result}";

    //$newval : transform-each(-4, false , (multiplier: 300),value);
   // $newval : transform-  by-list(2 sm,$_units,false, (multiplier: 300px),value);


    @return $result;
}

// /replacement ms function becomes a 'gate' .
@function get-scale-value2($_scale-def-key:type /* can be a scale def KEY or scaledef map */, $_value:1 /*value OR value key*/
) {
    ///if the definition key can either be a key in the scale definition objects "units" prop,
    // or it can be the whole scale definition (if one isnt registered or something "on the fly' modifications.

    $current-scale-definition: ();
    $current-value: false;

    @if (type-of($_scale-def-key)==map) {
        $current-scale-definition: $_scale-def-key;
    } @else if (validate-scale-definition-key($_scale-def-key)) {

        //  @debug "---------------------------------------";

        $current-scale-definition: get-scale-def($_scale-def-key);
    }

    //see if the value is a key that needs to be converted to the actual value/
    @if (is-valid-lookup-key($current-scale-definition, $_value)) {
        $current-value: get-value-by-key($current-scale-definition, $_value);

        //  @debug "scale definition , : #{$current-scale-definition} cleanvalue #{$_value} value processed: #{$current-value}";

    } @else if ($_value) {
        $current-value: $_value;
        /// defined values can be assigned directly.
    }
    $transformation-func: false;
    //check to see if transformation needs to be applied. if none present, just return the value.
    @if (is-valid-transformation(map-get($current-scale-definition, transform))) {

        $transformation-func: get-function(map-get($current-scale-definition, transform));
        //apply the transformation i guess???

    }

    ///options ( SHOULD BE A MAP. )
    $_options: (map-get($current-scale-definition, options));
    //todo: mybe validate function here
    @if ($_options == undefined or type-of($_options) != map) {
        $_options: ();
    }

    $args: (v:$current-value); //map default args object

    //merge the maps with additional parameters for functions.
    $args: map-merge($args, $_options);

    @if ($transformation-func) {
        ///do transformation
        @return call($transformation-func, $args...);

    } @else {
        ///return the args object
        @return $args;
    }

    //in order to provide a VALUE to a transformation function, it needs to be a NUMBER.    2, or 20px are acceptable values.
    @return false;
}